<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Rust Router Kernel - Emerging Trends</title>
        <style>
            html, body {
                font-family: Arial, sans-serif;
                line-height: 1.6;
                max-width: 800px;
                margin: auto;
                padding: 20px;
                background-color: #333;
            }
            
            h1, h2, h3, h4 {
                color: #dfdfdf;
            }
            
            p, ul {
                color: #c9c9c9;
            }
            
            a {
                color: #c9c9c9;
            }
            
            code {
                /* color: #333; */
                background: #444444;
                padding: 2px 5px;
                border-radius: 3px;
            }

            .section {
                margin-bottom: 20px;
            }

            .subsection {
                margin-left: 20px;
            }
        </style>
    </head>
    <body>
        <h1>Rust Router Kernel - Emerging Trends</h1>

        <div class="section">
            <p>
                This project focused on exploring the emerging trend of development with rust,
                through developing a minimal kernel. The kernel was intended for a router and
                developed by:
            </p>
            <ul>
                <li><a href="https://www.linkedin.com/in/yi-chen-lin-50bb5a137/">Yi-Chen(Zoe) Lin</a></li>
                <li><a href="https://www.linkedin.com/in/ethen-mitterhuber-43471a244/">Ethen Mitterhuber</a></li>
                <li><a href="https://www.linkedin.com/in/aryan-rattan-89693523a/">Aryan Rattan</a></li>
            </ul>
            <p>
                Ethen Mitterhuber While only making it
                to the end of the bootloader, the project still taught each of us lots about both
                rust development and OSDev.
            </p>
        </div>

        <div class="section">
            <h2>Emerging Trends</h2>
            <h3>Technical</h3>
            <div class="subsection">
                <h4>Development with Rust</h4>
                <p>
                    Rust is an emerging low-level language that enforces memory safety, making it increasingly attractive for systems
                    programming.
                </p>
            </div>
            <div class="subsection">
                <h4>DIY Kernel Development</h4>
                <p>
                    Interest in OS development has increased recently due to the availability of more resources, which has lowered
                    the barrier to entry.
                </p>
            </div>
            <div class="subsection">
                <h4>Embedded Systems Development</h4>
                <p>
                    While not a new concept, embedded systems development has seen a major increase in activity due to the
                    increasing demand for IoT (Internet of Things) devices.
                </p>
            </div>


            <h3>Non-Technical</h3>
            <div class="subsection">
                <h4>Self-guided AI-based learning</h4>
                <p>
                    Each member relied heavily on the use of AI in terms of learning what was needed in a kernel.
                    This allowed us to utilize AI as a tool to gain a high-level understanding of what is involved in kernel development. [cite: 4, 5]
                </p>
            </div>
            <div class="subsection">
                <h4>Remote team collaboration</h4>
                <p>
                    Most of the project was done remotely, with each member stating what they intended to work on,
                    then going off on their own to research and implement a solution. 
                    This allowed each of us to focus on one thing at a time, and gain a deep understanding of that topic.
                </p>
            </div>
            <div class="subsection">
                <h4>Agile development methodology</h4>
                <p>
                    While the kernel didn't get past the bootloader, the initial plan for the kernel was based on the agile methodology. 
                    Our intention was to get the foundation out the first sprint, implement networking features the second sprint,
                    then add in extra features in the last sprint.
                </p>
            </div>
        </div>

        <div class="section">
            <h2>Why Rust?</h2>
            <p>Rust was chosen for its advantages in kernel development:</p>
            <div class="subsection">
                <h3>Safer Entry Point</h3>
                <p>
                    Rust offers a safer entry point than the C language.
                    For example, the <code>#[entry]</code> macro is used to define the entry point, removing the need for an unsafe block.
                    This clean and safe structure is better than typical C-style boot code and demonstrates how Rust enables safer boot code design. [cite: 8, 9]
                </p>
            </div>
            <div class="subsection">
                <h3>Type-Safe Logging</h3>
                <p>
                    Rust enables type-safe logging with macros like <code>info!()</code>.
                    This eliminates the need for manual format specifiers (like %d or %s) as the compiler checks that the number of <code>{}</code> placeholders matches the number of arguments and ensures all arguments implement <code>Display</code> or <code>Debug</code>. [cite: 10, 11]
                    This prevents runtime crashes caused by incorrect formatting. 
                </p>
            </div>
            <div class="subsection">
                <h3>Safe Error Handling</h3>
                <p>
                    Rust uses <code>Result&lt;T, E&gt;</code> for safe error handling.
                    Functions like <code>read_in_kernel</code> return <code>Result&lt;T, E&gt;</code> to let the caller decide how to handle errors. [cite: 12, 13, 14]
                    Rust forces developers to handle errors directly, avoiding bugs caused by ignored failures, and integrates with Rust's pattern matching for clear and consistent logic. [cite: 14, 15]
                </p>
            </div>
            <div class="subsection">
                <h3>Safe Error Handling In Action</h3>
                <p>
                    The <code>match</code> keyword is used to explicitly handle both <code>Ok</code> and <code>Err</code> cases. 
                    If reading the kernel file fails, the caller logs the error and stops the boot process, which keeps the system from continuing in an invalid or incomplete state and prevents overlooked errors since the compiler requires all outcomes to be handled. [cite: 16, 17, 18]
                </p>
            </div>
        </div>

        <div class="section">
            <h2>Technical Aspects</h2>
            <div class="subsection">
                <h4>Rust for Memory-Safe Kernel Development</h4>
                <p>
                    Rust is being adopted for low-level OS development due to its memory safety features and performance.
                </p>
            </div>
            <div class="subsection">
                <h4>Minimal & Modular Kernels</h4>
                <p>
                    There's a growing interest in creating lightweight, modular kernels that can be customized for specific needs.
                    Minimal kernels reduce the attack surface, offering better security and stability.
                </p>
            </div>
            <div class="subsection">
                <h4>Boot Sequence</h4>
                <p>
                    The first thing to start up on a computer is the BIOS/UEFI.
                    This firmware performs a Power On Self Test (POST), checking to ensure all hardware is accounted for and working properly.
                    Control is then passed onto the bootloader.
                    The bootloader’s responsibility is to initialize the system, load the kernel into memory and pass execution off to the kernel.
                    Bootloaders work differently on BIOS and UEFI based systems.
                    BIOS-based systems have 512 bytes to work with for the bootloader.
                    UEFI does not have this restriction but can be built in this way to ensure compatibility with BIOS systems.
                    The bootloader then passes control off to the kernel when the system is initialized.
                    The kernel is the part of an operating system that communicates with the hardware.
                </p>
            </div>
            <div class="subsection">
                <h4>ELF Files - Intro</h4>
                <p>
                    The standard executable format for Linux systems is ELF (Executable and Linkable Format).
                    The kernel was built using WSL on most of our computers, so the compiler built the kernel executable as an ELF.
                    The bootloader needs to parse the kernel executable, load it into memory and pass execution off to the kernel entry function (_start).
                    As a result, a deep understanding of the structure of the ELF file is needed.
                    The Windows counterpart is the Portable Executable, which is also the format of the bootloader! (UEFI uses PE as the bootloader file format).
                </p>
            </div>
            <div class="subsection">
                <h4>ELF Files - Structure</h4>
                <p>
                    Each ELF file is made up of:
                </p>
                <ul>
                    <li>
                        <b>ELF header:</b>
                        <ul>
                            <li>Contains a magic number (bytes: 0x7F 0x45 0x4c 0x46, the last three spell ELF).</li>
                            <li>Contains other information about the type of computer this file was built for.</li>
                            <li>Stores the number and size of each entry, and the offset to the program header and section header tables.</li>
                            <li>The information for the program header table is important.</li>
                        </ul>
                    </li>
                    <li>
                        <b>Program header table:</b>
                        <ul>
                            <li>Stores information about each segment in the file.</li>
                            <li>Segment offset in file.</li>
                            <li>Size in file and in memory (does not have to match, memory size can be larger).</li>
                            <li>The virtual address to load the segment into.</li>
                        </ul>
                    </li>
                    <li>
                        <b>Segments:</b>
                        <ul>
                            <li>Contains the data stored in the executable.</li>
                            <li>Each segment contains a specific type.</li>
                            <li>Any with a type of PT_LOAD (1) needs to be loaded into memory.</li>
                        </ul>
                    </li>
                    <li>
                        <b>Sections (not mandatory for loading)</b>
                    </li>
                    <li>
                        <b>Section header table (not mandatory for loading)</b>
                    </li>
                </ul>
                <p>further reading: <a href="https://wiki.osdev.org/ELF">OSDev - ELF</a></p>
            </div>
        </div>

        <div class="section">
            <h2>Ethical Issues</h2>
            <p>The project considered several ethical concerns:</p>
            <div class="subsection">
                <h4>Low-Level System Security</h4>
                <p>
                    Through the development of the kernel, the developers were in control of everything that the OS needs to implement. 
                    Ensuring proper handling of features like memory management is critical, as a poorly managed system can lead to severe vulnerabilities, leaving the user open to attacks or the system open to crashes. 
                </p>
            </div>
            <div class="subsection">
                <h4>Software Freedom and User Autonomy</h4>
                <p>
                    Most users run operating systems they don’t control. 
                    By building their own, the developers gained complete control over what their system does, demonstrating how little control users often have over the systems they use daily. 
                </p>
            </div>
            <div class="subsection">
                <h4>Privacy and Data Access</h4>
                <p>
                    Developing a kernel means defining who can access what (e.g., what memory processes can access, defining methods for access control in user mode). 
                    Therefore, it's crucial to ensure that the system can effectively protect user data from unwanted access. 
                    This is especially important for a router kernel, where improper access control and data protection could allow attackers to enter a network. 
                </p>
            </div>
        </div>
    </body>
</html>
